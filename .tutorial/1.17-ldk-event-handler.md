# Handling Events

The next piece we'll need to configure for our LDK Lightning node to operate effectively is event handling. As we mentioned earlier, LDK utilizes an event-drive architecture, which nicely compliments its design as an environment agnostic software development kit, allowing us to choose own own data storage, wallet, networking stack, and blockchain monitoring. 

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/ldk_events.png" alt="ldk_events" width="100%" height="auto">
</p>

## Event Handling In Action

To build our intuition for events in LDK, let's review the example of how our Replit-based Lightning node will communicate when opening channels with other nodes!

In our next exercise, we'll complete a function that initiates a channel open with another node, passing along all of the necessary information to acomlish this taks: funding amount, peer details, etc.

Under the hood, our LDK node will send an `open_channel` protocol message to our peer. If our peer response with the `accept_channel` protocol message, LDK will provide us with a `FundingGenerated` event, informing us that we need to create a funding transaction for this channel. *REMEMEBR* how we created our own BDK wallet and equiped it with the ability to fetch UTXOs and craft funding transactions? Well, we will use this function to generate a funding transaction with the information that LDK provides in the `FundingGenerated` event. Once our wallet creates that transaction, we'll will hand it back to LDK, and LDK will continue with the channel open steps by sending a `funding_created` protocol message to our peer. 

See the picture below to see this process visually.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/events.png" alt="events" width="100%" height="auto">
</p>

#### Question: Why does LDK inform us that we need to create a fundning transaction? Why doesn't LDK do this for us?
<details>
  <summary>Answer</summary>

There are a few reasons for this.

1) **Customization:** LDK is purposefully built to allow for greater customization when building Lightning network applications. For example, in this workshop, we chose to build our on-chain wallet using the [Bitcoin Development Kit](https://bitcoindevkit.org/). However, we could have chosen to connect to Bitcoin Core for our on-chain wallet. Since this on-chain integration is left to us, LDK will let us decide how to create the funding transaction and which UTXOs to select by simply informing us that a transaction needs to be created. 

2) **Separation of Concerns**: By leaving on-chain transaction handling up to us, LDK is able to focus on implementing the Lightning protocol logic, keeping it lightweight and flexible to many different implementations.

</details>


Finally, once we receive a `funding_signed` message from our peer, LDK will broadcast the funding transaction for us and inform us, via the `ChannelReady` event, once the appropriate number of confirmations have taken place.

#### Question: Why does LDK send a `ChannelReady` event?
<details>
  <summary>Answer</summary>

There isn't necessarily a correct answer here! Instead, this question is just meant to spur our thought process towards how an application will work with an event-driven architecture.

One possible answer is that our application may want to inform the user (via a push notification, for example) that a channel is open and ready to be used.

</details>

## Setting Up Event Handling

To set up an **Event Handler**, we'll need to define a function that can process each event type that LDK will expose. You can find a complete list of them [here](https://docs.rs/lightning/latest/lightning/events/enum.Event.html), but a few have also been provided below.

Once the event handler has been created, it will be passed into our background processor to handle events as they occur.

```rust
pub enum Event {
  FundingGenerationReady {
    temporary_channel_id, // temporary channel id of channel requesting to be opened
    counterparty_node_id, // node id of counterparty requesting to open channel
    channel_value_satoshis, // channel value
    output_script, // the script to be used in the TX output
    ..
  },
  OpenChannelRequest {
    temporary_channel_id, // temporary channel id of channel requesting to be opened
    counterparty_node_id, // node id of counterparty requesting to open channel
    funding_satoshis, // channel value
    ..
  },
  ChannelPending {..},
  ChannelReady {..},
  PaymentSent {..},
  PaymentFailed {..},
  PaymentPathSuccessful {..},
  PaymentPathFailed {..},
  ProbeSuccessful {..},
  ProbeFailed {..},
  PendingHTLCsForwardable {..},
  HTLCIntercepted {..},
  PaymentForwarded {..},
  DiscardFunding {..},
}
```


### ⚡️ Implement `FundingGenerationReady` for `handle_ldk_events`

Let's go ahead and start implementing our event handler! To do this, head over to `src/events.rs`, where we'll create an asyncronous `handle_ldk_events` function. As you can see, this will have access to some of the  many of the structures that we've reviewed as part of this workshop, such as:
- ChannelManager
- BitcoinClient
- KeysManager
- PeerManager
- FileStore

To complete this function, you'll need to complete the `FundingGenerationReady` portion of the match statement. Within this code block, we'll need to construct a transaction with the information provided within the `Event` and pass it to the `channel_manager` using the `funding_transaction_generated` API. If you click the dropdown below, you'll notice that all of them are provided in the `Event` *except* for the funding transaction itself! 

<details>
  <summary>Click here to see the Channel Manager's funding_transaction_generated API</summary>

```rust
pub fn funding_transaction_generated(
    &self,
    temporary_channel_id: ChannelId,
    counterparty_node_id: PublicKey,
    funding_transaction: Transaction,
) -> Result<(), APIError>
```
</details>

Ultimately, we'll need to use the `create_funding_transaction` method that we implemented for our onchain wallet to build a transaction and hand it back to LDK. As a reminder, the inputs to the `create_funding_transaction` can be seen in the dropdown below.


<details>
  <summary>Click here to see our onchain wallet's create_funding_transaction</summary>

```rust
pub fn create_funding_transaction(&self,
output_script: ScriptBuf,
amount: Amount,
confirmation_target: ConfirmationTarget,
locktime: LockTime) -> Transaction
```
</details>

```rust
pub async fn handle_ldk_events(
    channel_manager: &ChannelManager, 
    bitcoind_client: BitcoindClient,
    on_chain_wallet: OnChainWallet,
    keys_manager: KeysManager, 
    peer_manager: PeerManager,
    file_store: FileStore,
    event: Event
) {
    match event {
        Event::FundingGenerationReady {
            temporary_channel_id,
            counterparty_node_id,
            channel_value_satoshis,
            output_script,
            ..
        } => {

            // Step 1: Set Confirmation Target

            // Step 2: Set Locktime

            // Step 3: Convert Channel Value to Amount Type

            // Step 4: Create Funding Transaction

            // Step 5: Give Funding Transaction To LDK
          
        },
        Event::FundingTxBroadcastSafe { .. } => {},
        Event::PaymentClaimable { .. } => {},
        Event::PendingHTLCsForwardable { .. } => {},
        Event::SpendableOutputs { .. } => {},
        Event::ChannelReady { .. } => {},
        Event::ChannelClosed { .. } => {},
        _ => {},
    }
}
```

<details> <summary>Step 1: Set Confirmation Target</summary>

Okay, so our main goal is to call the `create_funding_transaction` function and generate a funding transaction that we can hand to LDK. If we look at the transaction below, you'll notice that a few of these things are provided to us in the `Event::FundingGenerationReady`. Namely, the `output_script`, and `amount` (called `channel_value_satoshis`).

However, the confirmation and locktime are not provided in the event, so we need to create them ourselves. Let's start with `confirmation_target`.

```rust
pub fn create_funding_transaction(&self,
output_script: ScriptBuf,
amount: Amount,
confirmation_target: ConfirmationTarget,
locktime: LockTime) -> Transaction
```

When creating a funding transaction, we'll need to attach fees so that miners will include it in a block. Recall how earlier we specified many different types of `ConfirmationTarget`? If you look back, you'll see that these were specifically for off-chain situations in Lightning, but we can still use them to retrieve fees for on-chain purposes, like opening a channel.

When opening a channel, there isn't a rush necessarily to get the funding transaction mined (unless we want to start using the channel ASAP). So, for this example, let's set the `confirmation_target` to `NonAnchorChannelFee`. This is **not** because we're opening a lightning channel without anchors! Instead, it's because the `NonAnchorChannelFee` corresponds to a reasonable fee target (about 12 blocks). Go ahead and look back in  `src/bitcoind_client.rs` if you want to confirm this! It happens in 'poll_for_fee_estimates'. 

```rust
let confirmation_target = ConfirmationTarget::NonAnchorChannelFee;

```
</details>

<details> <summary>Step 2: Set Locktime</summary>

The next thing we need to create to pass into our `create_funding_transaction` is the locktime. We have a few options here!

#### LockTime Zero
One option is to not specify a locktime, meaning the transaction can be mined whenever. This can be done using the below code.

```rust
let locktime = LockTime::ZERO
```
#### Current Block Height
Another option, which is popular among many wallet providers, is to set the locktime to the current block height when creating a transaction. This is because, by setting the locktime to the current block height, the transaction is immediately spendable, *but it also discourages fee sniping*.

For instance, imagine a future (which is coming!) where all of the miner revenue come from transaction fees (instead of block subsidy). Furthermore, imagine the last block had some transactions with pretty large fees. In this scenario, large miners may be encouraged to re-org the past block and include high-fee transactions from the mempool. However, if we set the locktime to the current height, we discourage this behavior because the miner would be unable to include our transaction in their re-ord.

With this in mind, let's set the locktime to the current block height! We can do that by first fetching the current block height from our Channel Manager, and then creating a locktime object with the current height.

```rust
let cur_height = channel_manager.current_best_block().height;
let locktime = LockTime::from_height(cur_height).unwrap();
```
- `channel_manager.current_best_block()` returns information about the latest known block.
- `.height` extracts the block height as a `u32`.

</details>

<details> <summary>Step 3: Convert Channel Value to Amount Type</summary>

Next, we'll have to do a quick conversion of the `channel_value_satoshis`, which comes in as a `u64` from the `Event`, into an `Amount`, as defined by the bitcoin crate. 

```rust
let channel_amount = Amount::from_sat(channel_value_satoshis);
```
- `Amount::from_sat()` converts satoshis (`u64`) to the `Amount` type.


</details>

<details> <summary> Step 4: Create Funding Transaction </summary>

Awesome, we're finally at the point where we can create our funding transaction using our wallet's `create_funding_transaction` function. Go ahead and plug everything in!

```rust
let final_tx = on_chain_wallet.create_funding_transaction(
    output_script,
    channel_amount,
    confirmation_target,
    locktime
);
```
</details>

<details> <summary> Step 5: Give Funding Transaction To LDK </summary>

Now that we have our funding transaction, we can hand it back to LDK so that LDK can continue with the protocol messaging and help us open our channel. To do this, we call the Channel Manager's `funding_transaction_generated` API.

```rust
channel_manager.funding_transaction_generated(
    temporary_channel_id,
    counterparty_node_id,
    final_tx
);
```
- `temporary_channel_id` is a random `channel_id` that LDK generates, which we get from the `FundingGenerationReady` event and need to pass into `funding_transaction_generated`
- `counterparty_node_id` is the public node ID for our counterparty
</details>

## Starting The Event Handler

Once we've configured our custom logic for handling LDK events, we'll need to start a **background processor**. The background processor will orchestate all of the components that we've created, glueing them together so that they can communicate with each other and process events accordingly. LDK provides a `lightning-background-processor` crate with both synchronous and asychronous background processing implementations that developers can use.

The **event handler** that we defined previously will be provided to the background processor as an input.
When processing events, LDK will first handle events itself, then it will pass those events on to our custom event handler for further processing.

For example, when payments (or probes) succeed or fail, LDK updates its internal scorer so that it can better estimate the capcaity of any given channel and optimize future routing. These events (`PaymentPathSuccessful`, `PaymentPathFailed`, `ProbeSuccessful`, `ProbeFailed`) will be processed first by LDK via the background processor, and then they will be passed on to our custom handler for, if applicable, further processing.

<details>
  <summary>Click to see how the lightning-background-processor updates the scorer</summary>

Below is a view into the `lightning-background-processor` to help build our intuition as to how it works. In this code snippet, you'll see the function `update_scorer`, which takes a `scorer`, `event`, and `duration_since_epoch` as inputs. Whenever an event is recieved that relates to payment (or probe) results, the background processor will call this function and process the event. 

```rust
/// Updates scorer based on event and returns whether an update occurred so we can decide whether
/// to persist.
fn update_scorer<'a, S: 'static + Deref<Target = SC> + Send + Sync, SC: 'a + WriteableScore<'a>>(
  scorer: &'a S, event: &Event, duration_since_epoch: Duration,
) -> bool {
  match event {
    Event::PaymentPathFailed { ref path, short_channel_id: Some(scid), .. } => {
      let mut score = scorer.write_lock();
      score.payment_path_failed(path, *scid, duration_since_epoch);
    },
    Event::PaymentPathFailed { ref path, payment_failed_permanently: true, .. } => {
      // Reached if the destination explicitly failed it back. We treat this as a successful probe
      // because the payment made it all the way to the destination with sufficient liquidity.
      let mut score = scorer.write_lock();
      score.probe_successful(path, duration_since_epoch);
    },
    Event::PaymentPathSuccessful { path, .. } => {
      let mut score = scorer.write_lock();
      score.payment_path_successful(path, duration_since_epoch);
    },
    Event::ProbeSuccessful { path, .. } => {
      let mut score = scorer.write_lock();
      score.probe_successful(path, duration_since_epoch);
    },
    Event::ProbeFailed { path, short_channel_id: Some(scid), .. } => {
      let mut score = scorer.write_lock();
      score.probe_failed(path, *scid, duration_since_epoch);
    },
    _ => return false,
  }
  true
}
```

</details>

### Initializing The Background Processor
As mentioned above, the Background Processor is a critical component that handles essential tasks like event processing, channel state persistence, and network maintenance. Below is an example of initializing an async Background Processor using Tokio, which sets up all necessary components including the persister, event handler, chain monitor, and other core LDK services. The processor runs continuously until explicitly stopped:

```rust
// Background Processing
let (bp_exit, bp_exit_check) = tokio::sync::watch::channel(());
let mut background_processor = tokio::spawn(lightning_background_processor::process_events_async(
  Arc::clone(&persister),
  event_handler,
  chain_monitor.clone(),
  channel_manager.clone(),
  Some(onion_messenger),
  GossipSync::p2p(gossip_sync.clone()),
  peer_manager.clone(),
  logger.clone(),
  Some(scorer.clone()),
  move |t| {
    let mut bp_exit_fut_check = bp_exit_check.clone();
    Box::pin(async move {
      tokio::select! {
        _ = tokio::time::sleep(t) => false,
        _ = bp_exit_fut_check.changed() => true,
      }
    })
  },
  false,
  || Some(SystemTime::now().duration_since(SystemTime::UNIX_EPOCH).unwrap()),
));
```