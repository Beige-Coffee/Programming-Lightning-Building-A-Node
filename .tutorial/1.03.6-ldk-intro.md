# Rust & LDK
Now that we've learned some of the Rust basics, let's continue digging into the weeds while also starting to tie things together with LDK.

## Lightning Development Kit
The **Lightning Development Kit** (**LDK**) is a library that implements the Lightning network protocol but gives you the ability to integrate it directly into your application in exactly the fashion that best suits your needs. The core implementation is written in Rust, but there are bindings are in other languages such as Kotlin and Swift (with more comming!).

Below is a high-level image of LDK's architecture. There are a few important things to notice:

1) **LDK API**: At the core of LDK is an API with hundreds of methods. All we have to do is configured the node correctly by implementing the various interfaces, intantiating the required components, and handling pre-specified events.
2) **Interfaces**: The boxes with dotted borders are LDK's modules — these must be configured with either default or custom implementations that developers provide. **Much of this course will involve implementing these interfaces**.
3) **Events**: LDK leverages an event-driven architecture, notifying app developers when certain events occur (such as opening channels, responding to counterparty revocations, etc.) that need attention. As we'll see, one major benefit to the event-driven architecture is that it provides developers with much more customization for how they'd like to configure their node.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/ldk-architecture.svg" alt="ldk-architecture" width="100%" height="auto">
</p>

# Traits
LDK is able to provide a high degree of customization because it exposes **traits**. A **trait** defines a set of methods that a type must implement. In computer science parlance, traits enable **polymorphism**, which means that you can write code that implements a given trait, regardless of the type's concrete details. This is a **very** important thing to understand, so let's learn by example!

## LDK Traits
LDK uses **traits** to define **interfaces for pluggable components**. As we'll learn in this course, LDK makes various interfaces available so that we can define things such as:
- Where we will source blockchain data from (Bitcoin Core, Esplora, Electrum, etc.)
- How we'd like to estimate fees (Bitcoin Core, mempool.space, etc.)
- Where we'd like to persist our Lightning node's data (file system, sql database, etc.)
- and so much more...

## Logger
The Lightning Development Kit (LDK) defines the `Logger` trait to enable custom logging in your Lightning node. This trait specifies a single method, `log`, which any type implementing `Logger` must provide. By implementing `Logger`, you can control how LDK logs important events, such as channel openings, payment failures, or network updates, to suit your application (e.g., writing to a file, printing to the console, or sending to a monitoring service).

The `Logger` trait is defined as follows (see the LDK Rust docs for more details: [Logger Trait](https://docs.rs/lightning/latest/lightning/util/logger/trait.Logger.html)):

```rust
/// A trait encapsulating the operations required of a logger.
pub trait Logger {
    /// Logs the [`Record`].
    fn log(&self, record: Record);
}
```
The `Record` type is provided by LDK, and it includes details like the log level, module path, and line number, allowing LDK to format logs precisely.

<details> <summary> Click to see LDK's `Record` struct. </summary>

```rust
pub struct Record<'a> {
        pub level: Level,
        pub peer_id: Option<PublicKey>,
        pub channel_id: Option<ChannelId>,
        pub args: Arguments<'a>,
        pub module_path: &'static str,
        pub file: &'static str,
        pub line: u32,
        pub payment_hash: Option<PaymentHash>,
}
```
</details>

As discussed earlier, traits like `Logger` enable LDK to abstract behavior, calling `.log()` without knowing your implementation details. This pattern, common in LDK with traits like `FeeEstimator` and `BroadcasterInterface` (which we will learn about soon!), is key to building a flexible and robust Lightning node.

## Start With The End In Mind...
It can be helpful to start our journey by defining our end. In this case, from a coding perspective, what is the goal of our logger? Of course, we want to enable LDK to log important information, but we also want to create an object that contains the logging functionality, which we can then pass to other LDK components as we initialize them.

For instance, in the below example, we are intantiating a `ChainMonitor` object, which is responsible for monitoring on-chain transactions to ensure that we can react accordingly (ex: funding transaction is mined, counterparty broadcasts old state, etc.). When we intantiate this object, we'll need to pass in a logger (along with some other components we'll create during this workshop!). 

```rust
let chain_monitor: Arc<ChainMonitor> = Arc::new(chainmonitor::ChainMonitor::new(
    None,
    Arc::clone(&broadcaster),
    Arc::clone(&logger),
    Arc::clone(&fee_estimator),
    Arc::clone(&persister),
));
```

## Define FilesystemLogger
Before implementing the `Logger` trait, we'll need a concrete type that we can apply it to, such as a struct, enum, or primitive type. In this case, we’ll use a struct, which is a common choice for trait implementations in Rust. Our struct will hold a path to our log directory. This will be the parent directory, and all of our logs will be organized under here. This struct will serve as the concrete type for implementing the `Logger` trait in the next section.

```rust
pub(crate) struct FilesystemLogger {
    pub data_dir: String,
}
```

## ⚡️ Implement `new` Constructor For FilesystemLogger
Now that we’ve defined our `FilesystemLogger` struct, we need a way to create new instances of the struct. Otherwise, how would we ever be able to create a logger object and hand it to LDK?! In Rust, this is typically done with a `new` constructor, an associated function that returns a new struct instance initialized with provided data.

Let’s implement the new constructor for `FilesystemLogger` to create an instance that holds a `data_dir` (a `String` for the log directory path). This constructor prepares `FilesystemLogger` for implementing the `Logger` trait in the next exercise.

```rust
impl FilesystemLogger {
    pub(crate) fn new(data_dir: String) -> Self {
        // Step 1. Build logs path by appending "/logs" to data_dir.

        // Step 2. Create logs directory, cloning path for ownership. `unwrap` assumes success.

        // Step 3. Return FilesystemLogger with logs_path as data_dir.
    }
}
```

<details> <summary> Step 1: Build Logs Path </summary>
    
Construct the path for the logs directory by appending "/logs" to the provided `data_dir` using the `format!` macro.

```rust
let logs_path = format!("{}/logs", data_dir);
```
- `format!("{}/logs", data_dir)` creates a `String` like `/path/to/data_dir/logs` by combining `data_dir` with "/logs".
- The `format!` macro interpolates `data_dir` into the string template, returning a new `String`.
- `data_dir` is not consumed, so it can be used later if needed.

</details>

<details> <summary> Step 2: Create Logs Directory </summary>
    
Create the logs directory and any necessary parent directories using `fs::create_dir_all`, cloning the path to satisfy ownership requirements.

```rust
fs::create_dir_all(logs_path.clone()).unwrap();
```
- `logs_path.clone()` creates a copy of the `logs_path` `String`, as `fs::create_dir_all` takes ownership of its argument.
- `fs::create_dir_all` (from the `std::fs` library) creates the directory at `logs_path` and all parent directories if they don’t exist, returning a `Result<(), std::io::Error>`.
- `.unwrap()` extracts the `Ok(())` value, panicking if an error occurs (e.g., permission denied). In production, handle errors gracefully.

</details>

<details> <summary> Step 3: Return FilesystemLogger </summary>
    
Construct and return a `FilesystemLogger` instance with the `logs_path` as its `data_dir`.

```rust
Self {
    data_dir: logs_path,
}
```
- `Self` refers to the `FilesystemLogger` struct.
- Assign `logs_path` to the `data_dir` field, moving the `String` into the struct.
- The constructor returns the initialized `FilesystemLogger` instance.

</details>

## ⚡️ Implement LDK `Logger` Trait For FilesystemLogger
The `Logger` trait in LDK is a critical interface for defining how logging is handled in your Lightning node. Logging is essential for debugging, monitoring, and auditing node operations, such as channel events, peer connections, or errors. The `Logger` trait defines a single method, `log`, which takes a `Record` (containing log details like message, level, module, and line number) and processes it according to the implementation.

Building on our `FilesystemLogger` struct and the `Logger` trait, this exercise completes our logging setup by implementing `Logger` for `FilesystemLogger`. This enables LDK to write log messages to a file, providing a persistent record for troubleshooting. Our implementation will format logs with a timestamp, log level, module path, line number, and message, then append them to `logs.txt`.

The `Logger` trait’s flexibility allows LDK to call `log` without knowing the implementation details, enabling custom logging (e.g., to files, consoles, or services) while ensuring compatibility with LDK’s architecture.

```rust
impl Logger for FilesystemLogger {
    fn log(&self, record: Record) {
        // Step 1: Extract and format log message

        // Step 2: Format full log entry with timestamp and metadata

        // Step 3: Construct log file path

        // Step 4: Write log to file
    }
}
```

<details> <summary> Step 1: Extract and Format Log Message </summary> 
    
Extract the log message from the `Record`’s `args` field and convert it to a `String`.

```rust
let raw_log = record.args.to_string();
```
- `record.args` contains the log message, which implements `std::fmt::Arguments`.
- `.to_string()` converts the arguments to a `String`, capturing the message content.
- Store the result in `raw_log` for use in the formatted log entry.
</details>

<details> <summary>Step 2: Format Full Log Entry with Timestamp and Metadata</summary>

Format the log entry with a timestamp, log level, module path, line number, and the raw log message.

```rust
let log = format!(
    "{} {:<5} [{}:{}] {}\n",
    Utc::now().format("%Y-%m-%d %H:%M:%S%.3f"),
    record.level.to_string(),
    record.module_path,
    record.line,
    raw_log
);
```
- `format!(...)` creates a `String` with the log entry.
- `Utc::now().format("%Y-%m-%d %H:%M:%S%.3f")` generates a timestamp (e.g., `2023-10-05 14:30:45.123`).
- `record.level.to_string()` gets the log level (e.g., `INFO`, `ERROR`) as a `String`.
- `{:5}` left-aligns the level with a width of 5 characters for consistent formatting.
- `record.module_path` and `record.line` provide the module and line number where the log was triggered.
- `raw_log` is the message from Step 1.
- `\n` adds a newline for readability in the log file.
</details>

<details> <summary>Step 3: Construct Log File Path</summary>
    
Build the path to the log file by appending `/logs.txt` to the `data_dir`.

```rust
let logs_file_path = format!("{}/logs.txt", self.data_dir.clone());
```
- `self.data_dir.clone()` creates a copy of the `data_dir` `String`, as `format!` takes ownership of its arguments.
- `format!("{}/logs.txt", ...)` creates a path like `/path/to/data_dir/logs.txt`.
- Store the path in `logs_file_path` for use in file operations.
</details>

<details> <summary>Step 4: Write Log to File</summary>
    
Open the log file in append mode (creating it if it doesn’t exist) and write the formatted log entry.

```rust
fs::OpenOptions::new()
.create(true)
.append(true)
.open(logs_file_path)
.unwrap()
.write_all(log.as_bytes())
.unwrap();
```
- `fs::OpenOptions::new()` creates a new file options builder.
- `.create(true)` allows creating the file if it doesn’t exist.
- `.append(true)` opens the file in append mode to add new logs without overwriting.
- `.open(logs_file_path)` opens the file, returning a `Result<File, std::io::Error>`.
- `.unwrap()` extracts the `File`, panicking on error (e.g., permission denied); in production, handle errors gracefully.
- `.write_all(log.as_bytes())` writes the log entry as bytes to the file.
- `.unwrap()` assumes the write succeeds; handle errors in production.
</details>