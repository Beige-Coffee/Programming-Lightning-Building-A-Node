# Rust & LDK
Now that we've learned some of the Rust basics, let's continue digging into the weeds while also starting to tie things together with LDK.

## Lightning Development Kit
The **Lightning Development Kit** (**LDK**) is a library that implements the Lightning network protocol but gives you the ability to integrate it directly into your application in exactly the fashion that best suits your needs. The core implementation is written in Rust, but there are bindings are in other languages such as Kotlin and Swift (with more comming!).

Below is a high-level image of LDK's architecture. There are a few important things to notice:

1) **LDK API**: At the core of LDK is an API with hundreds of methods. All we have to do is configured the node correctly by implementing the various interfaces, intantiating the required components, and handling pre-specified events.
2) **Interfaces**: The boxes with dotted borders are LDK's modules — these must be configured with either default or custom implementations that developers provide. **Much of this course will involve implementing these interfaces**.
3) **Events**: LDK leverages an event-driven architecture, notifying app developers when certain events occur (such as opening channels, responding to counterparty revocations, etc.) that need attention. As we'll see, one major benefit to the event-driven architecture is that it provides developers with much more customization for how they'd like to configure their node.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/ldk-architecture.svg" alt="ldk-architecture" width="100%" height="auto">
</p>

# Traits
LDK is able to provide a high degree of customization because it exposes **traits**. A **trait** defines a set of *methods* that a type must implement. This is a **very** important thing to understand, so let's learn by example!

## LDK Traits
LDK uses **traits** to define **interfaces for pluggable components**. As we'll learn in this course, LDK makes various interfaces available so that we can define things such as:
- Where we will source blockchain data from (Bitcoin Core, Esplora, Electrum, etc.)
- How we'd like to estimate fees (Bitcoin Core, mempool.space, etc.)
- Where we'd like to persist our Lightning node's data (file system, sql database, etc.)
- and so much more...

## Logger
The Lightning Development Kit (LDK) defines the `Logger` trait to enable custom logging in your Lightning node. This trait specifies a single method, `log`, which any type implementing `Logger` must provide. By implementing `Logger`, you can control how LDK logs important events, such as channel openings, payment failures, or network updates. For example, your implementation of the `Logger` may write to a file, print to the console, or send to a monitoring service.

The `Logger` trait is defined as follows (see the LDK Rust docs for more details: [Logger Trait](https://docs.rs/lightning/latest/lightning/util/logger/trait.Logger.html)):

```rust
/// A trait encapsulating the operations required of a logger.
pub trait Logger {
    /// Logs the [`Record`].
    fn log(&self, record: Record);
}
```
As you'll see, the `log` function takes a `Record` type as an input. This type is provided by LDK, and it includes details like the log level, module path, and line number, allowing LDK to format logs precisely.

<details> <summary> Click to see LDK's `Record` struct. </summary>

```rust
pub struct Record<'a> {
        pub level: Level,
        pub peer_id: Option<PublicKey>,
        pub channel_id: Option<ChannelId>,
        pub args: Arguments<'a>,
        pub module_path: &'static str,
        pub file: &'static str,
        pub line: u32,
        pub payment_hash: Option<PaymentHash>,
}
```
</details>

As discussed earlier, traits like `Logger` enable LDK to abstract behavior. For instance, LDK can, internally, call `.log()` to log important details, and it will log that information in whichever manner you specify. This pattern, common in LDK with traits like `FeeEstimator` and `BroadcasterInterface` (which we will learn about soon!), is key to building a flexible and robust Lightning node.

## Start With The End In Mind...
It can be helpful to start our journey by defining our end. In this case, from a programming perspective, what is our goal? Of course, we want to enable LDK to log important information, but we also want to create an object that contains the logging functionality, which we can then pass to other LDK components as we initialize them.

For instance, in the below example, we are intantiating a `ChainMonitor` object, which is responsible for monitoring on-chain transactions to ensure that we can react accordingly (ex: funding transaction is mined, counterparty broadcasts old state, etc.). When we instantiate this object, we'll need to pass in a logger (along with some other components we'll create during this workshop!). 

```rust
let chain_monitor: Arc<ChainMonitor> = Arc::new(chainmonitor::ChainMonitor::new(
    None,
    Arc::clone(&broadcaster),
    Arc::clone(&logger), // pass in logger
    Arc::clone(&fee_estimator),
    Arc::clone(&persister),
));
```

## Define FilesystemLogger
Before implementing the `Logger` trait, we'll need a concrete type that we can apply it to, such as a struct, enum, or primitive type. In this case, we’ll use a struct, which is a common choice for trait implementations in Rust. Our struct will hold a path to our log directory. This will be the parent directory, and all of our logs will be organized under here. This struct will serve as the concrete type for implementing the `Logger` trait in the next section.

Head over to `src/logger.rs`! You'll see the `FilesystemLogger` has been defined for you. We'll be completing the implementation in the next few exercises.

```rust
pub(crate) struct FilesystemLogger {
    pub data_dir: String,
}
```

## ⚡️ Implement `new` Constructor For FilesystemLogger
Now that we’ve defined our `FilesystemLogger` struct, we need a way to create new instances of the struct. Otherwise, how would we ever be able to create a logger object and hand it to LDK?! In Rust, this is typically done with a `new` constructor, an associated function that returns a new struct instance initialized with provided data.

Let’s implement the new constructor for `FilesystemLogger` to create an instance that holds a `data_dir` (a `String` for the log directory path). This constructor prepares `FilesystemLogger` for implementing the `Logger` trait in the next exercise.

```rust
impl FilesystemLogger {
    pub(crate) fn new(data_dir: String) -> Self {
        // Step 1. Build logs path by appending "/logs" to data_dir.

        // Step 2. Create logs directory, cloning path for ownership. `unwrap` assumes success.

        // Step 3. Return FilesystemLogger with logs_path as data_dir.
    }
}
```

<details> <summary> Step 1: Build Logs Path </summary>
    
Construct the path for the logs directory by appending "/logs" to the provided `data_dir` using the `format!` macro. If you're new to Rust, you can think of a "macro" as a function, which takes input arguments and returns an output. 

```rust
let logs_path = format!("{}/logs", data_dir);
```
- `format!("{}/logs", data_dir)` creates a `String` like `/path/to/data_dir/logs` by combining `data_dir` with "/logs".
- The `format!` macro interpolates `data_dir` into the string template, returning a new `String`.
- `data_dir` is not consumed, so it can be used later if needed.

</details>

<details> <summary> Step 2: Create Logs Directory </summary>
    
Create the logs directory and any necessary parent directories using `fs::create_dir_all`. Since we'll be using `logs_path` later in our function, we'll need to clone it to ensure that we don't lose ownership over the variable.

Since `fs::create_dir_all()` returns a `Result`, we'll need to unwrap the result to and ensure there is not an error.

```rust
fs::create_dir_all(logs_path.clone()).unwrap();
```
- `logs_path.clone()` creates a copy of the `logs_path` `String`, as `fs::create_dir_all` takes ownership of its argument.
- `fs::create_dir_all` (from the `std::fs` library) creates the directory at `logs_path` and all parent directories if they don’t exist, returning a `Result<(), std::io::Error>`.
- `.unwrap()` extracts the `Ok(())` value, panicking if an error occurs (e.g., permission denied). In production, handle errors gracefully.

</details>

<details> <summary> Step 3: Return FilesystemLogger </summary>
    
Finally, let's construct and return a `FilesystemLogger` instance with the `logs_path` as its `data_dir`. To return the and instance of the `FilesystemLogger`, we can specify `Self` along with the `data_dir`.

```rust
Self {
    data_dir: logs_path,
}
```
- `Self` refers to the `FilesystemLogger` struct.
- Assign `logs_path` to the `data_dir` field, moving the `String` into the struct.

</details>

**You should be good-to-go! Try implementing the `new` constructor in `src/logger.rs`**! Click `Run` at the top of the Replit when you're done to see if the test `tests::programming_lightning::test_01_filesystem_logger_new ...` passes.

## ⚡️ Implement LDK `Logger` Trait For FilesystemLogger
The `Logger` trait in LDK is a critical interface for defining how logging is handled in your Lightning node. Logging is essential for debugging, monitoring, and auditing node operations, such as channel events, peer connections, or errors. The `Logger` trait defines a single method, `log`, which takes a `Record` (containing log details like message, level, module, and line number) and processes it according to the implementation.

Let's build on our `FilesystemLogger` struct by implementing the `Logger` trait, enabling LDK to write log messages to the local filesystem in our Replit. Our implementation will format logs with a timestamp, log level, module path, line number, and message, then append them to `logs.txt`.

```rust
impl Logger for FilesystemLogger {
    fn log(&self, record: Record) {
        // Step 1: Extract and format log message

        // Step 2: Format full log entry with timestamp and metadata

        // Step 3: Construct log file path

        // Step 4: Write log to file
    }
}
```

<details> <summary> Step 1: Extract and Format Log Message </summary> 
    
Extract the log message from the `Record`’s `args` field and convert it to a `String`.

```rust
let raw_log = record.args.to_string();
```
- `record.args` contains the log message, which implements `std::fmt::Arguments`.
- `.to_string()` converts the arguments to a `String`, capturing the message content.
</details>

<details> <summary>Step 2: Format Log Entry with Timestamp and Metadata</summary>

Format the log entry with a timestamp, log level, module path, line number, and the raw log message.

```rust
let log = format!(
    "{} {:<5} [{}:{}] {}\n",
    Utc::now().format("%Y-%m-%d %H:%M:%S%.3f"),
    record.level.to_string(),
    record.module_path,
    record.line,
    raw_log
);
```
- `format!(...)` creates a `String` with the log entry.
- `Utc::now().format("%Y-%m-%d %H:%M:%S%.3f")` generates a timestamp (e.g., `2023-10-05 14:30:45.123`).
- `record.level.to_string()` gets the log level (e.g., `INFO`, `ERROR`) as a `String`.
- `{:5}` left-aligns the level with a width of 5 characters for consistent formatting.
- `record.module_path` and `record.line` provide the module and line number where the log was triggered.
- `raw_log` is the message from Step 1.
- `\n` adds a newline for readability in the log file.
</details>

<details> <summary>Step 3: Construct Log File Path</summary>
    
Build the path to the log file by appending `/logs.txt` to the `data_dir`. The `format` macro takes ownership of variables, so we need to clone the `data_dir`, since we'll be using it again later in the function. If you look at the `new` construction from earlier, you'll notice we didn't clone the `data_dir` - do you know why?! It's because we didn't use the variable again, so it's okay if it drops out of the function's scope.

```rust
let logs_file_path = format!("{}/logs.txt", self.data_dir.clone());
```
- `self.data_dir.clone()` creates a copy of the `data_dir` `String`, as `format!` takes ownership of its arguments.
- `format!("{}/logs.txt", ...)` creates a path like `/path/to/data_dir/logs.txt`.

</details>

<details> <summary>Step 4: Write Log to File</summary>
    
Open the log file in append mode (creating it if it doesn’t exist) and write the formatted log entry.

```rust
fs::OpenOptions::new()
.create(true)
.append(true)
.open(logs_file_path)
.unwrap()
.write_all(log.as_bytes())
.unwrap();
```
- `fs::OpenOptions::new()` creates a new file options builder.
- `.create(true)` allows creating the file if it doesn’t exist.
- `.append(true)` opens the file in append mode to add new logs without overwriting.
- `.open(logs_file_path)` opens the file, returning a `Result<File, std::io::Error>`.
- `.unwrap()` extracts the `File`, panicking on error (e.g., permission denied); in production, handle errors gracefully.
- `.write_all(log.as_bytes())` writes the log entry as bytes to the file.
- `.unwrap()` assumes the write succeeds; handle errors in production.
</details>

**You should be good-to-go! Try implementing the `new` constructor in `src/logger.rs`**! Click `Run` at the top of the Replit when you're done to see if the test `test_02_filesystem_logger_log...` passes.
