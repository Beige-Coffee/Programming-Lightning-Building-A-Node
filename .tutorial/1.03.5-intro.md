# Rust Crash Course

Let's be honest. You won't learn Rust in this "crash course". However, hopefully, you'll build enough of an *intuition* as to how Rust works so that you can more easily move through the exercises. 

# Why Rust?
First and foremost, Rust is beautiful programming language. It can also be a massive pain, especially if you come from a higher-level programming background, such as Python. This is because Rust provides much more control over lower-level primatives such as memory management, concurrency, and ... For these reasons, Rust is often a prefered langauge for systems programming, where we need to be efficient and precise so that our program is optimized for our use-case.

Programming a node in the Lightning network invovles orchestrating various complex components to handle tasks such as networking, data storage, and communication with other nodes on the network. This is precicely the type of situation where deliberate systems programming makes a big difference. So, now that we've covered *why* we're using Rust

# Types
To build our intuition for Rust and, ultimately, how we'll go about architecting our Lightning node, let's start by reviewing **types**.

A **type** in Rust is a way to describe what kind of data a variable can hold and what operations we can perform on it. This is fundamental to how Rust ensures safety and correctness at compile time. There are a few categories of types in Rust, and they have been listed below.

#### Primitive Type
- **Numbers**: `u8`, `i32`, `f64`, etc.
- **Boolean**: `bool`
- **Characters**: `char`

#### Compound Types
- **Tuples**: `(i32, bool)`
- **Arrays**: `[u8; 32]`

#### Structs
- Custom data structures (more on this soon!)

# Traits
A **trait** defines a set of methods that a type must implement. In computer science parlance, traits enable **polymorphism**, which means that you can write code that implements a given trait, regardless of the type's concrete details. This is a **very** important thing to understand, so let's learn by example!

## LDK Traits
LDK uses **traits** extensively to define **interfaces for pluggable components**. As we'll learn in this course, LDK makes various interfaces available so that we can define things such as:
- Where we will source blockchain data from (Bitcoin Core, Esplora, Electrum, etc.)
- How we'd like to estimate fees (Bitcoin Core, mempool.space, etc.)
- Where we'd like to persist our Lightning node's data (file system, sql database, etc.)
- and so much more...

## Logger
One trait that LDK make available to us is the `Logger`. This trait defines one method, `log`, which all types that implement this trait *must* define. 

As we discussed earlier, the benefit of this approach is that LDK can use the `.log()` method within it's internal code base to log important information without knowing how developers will actually implement this function. It just knows that it will be implemented somehow.

```rust
/// A trait encapsulating the operations required of a logger.
pub trait Logger {
    /// Logs the [`Record`].
    fn log(&self, record: Record);
}
```

## Define FilesystemLogger
Remember how we introduced the concept of a **struct** as a "custom data structure" and then moved on. Well, let's circle back to that now.

Before we can implement a trait, we must have a concrete type to implement that trait for. This type can be a struct, enum, primitive type, tuple, or unit type, as long as either the trait or the type is local to our crate.

If you're coming from Python, a Rust struct is similar to a Python class, but with some key differences. While Python classes combine both data and methods, Rust separates them - structs define the data structure, and implementations (impl) define the behavior. Here's how we define our Logger in both languages:

#### Python
```python
class FilesystemLogger:
def __init__(self, data_dir: str):
    self.data_dir = data_dir
```

#### Rust
```rust
pub(crate) struct FilesystemLogger {
  pub data_dir: String,
}
```

In both cases, we're creating a type that holds a path to our log directory, but Rust's approach gives us more explicit control over the data structure and its behavior by keeping them separate.


## Implement `new` Constructor For FilesystemLogger
Now that we've defined our `FilesystemLogger` struct, we need a way to create instances of it. In Rust, this is typically done by implementing a `new` constructor. A constructor is just a function that returns a new instance of our struct, initialized with the data we provide.

In many programming languages, like Python, constructors are defined with special methods (e.g., `__init__`). In Rust, we define constructors as associated functions within an `impl` block for our struct. By convention, we name this function `new`, but Rust doesn't enforce this — it's just a common pattern.

Let's implement the new constructor for `FilesystemLogger`. Our goal is to create a `FilesystemLogger` instance that holds a `data_dir` (a String representing the directory where logs will be stored).

```rust
impl FilesystemLogger {
    pub(crate) fn new(data_dir: String) -> Self {
        // Step 1. Build logs path by appending "/logs" to data_dir.

        // Step 2. Create logs directory, cloning path for ownership. `unwrap` assumes success.

        // Step 3. Return FilesystemLogger with logs_path as data_dir.
    }
}
```

<details> <summary> Step 1: Build Logs Path </summary>
Construct the path for the logs directory by appending "/logs" to the provided `data_dir` using the `format!` macro.

```rust
let logs_path = format!("{}/logs", data_dir);
```
- `format!("{}/logs", data_dir)` creates a `String` like `/path/to/data_dir/logs` by combining `data_dir` with "/logs".
- The `format!` macro interpolates `data_dir` into the string template, returning a new `String`.
- `data_dir` is not consumed, so it can be used later if needed.

</details>

<details> <summary> Step 2: Create Logs Directory </summary>
Create the logs directory and any necessary parent directories using `fs::create_dir_all`, cloning the path to satisfy ownership requirements.

```rust
fs::create_dir_all(logs_path.clone()).unwrap();
```
- `logs_path.clone()` creates a copy of the `logs_path` `String`, as `fs::create_dir_all` takes ownership of its argument.
- `fs::create_dir_all` (from the `std::fs` library) creates the directory at `logs_path` and all parent directories if they don’t exist, returning a `Result<(), std::io::Error>`.
- `.unwrap()` extracts the `Ok(())` value, panicking if an error occurs (e.g., permission denied). In production, handle errors gracefully.

</details>

<details> <summary> Step 3: Return FilesystemLogger </summary>
Construct and return a `FilesystemLogger` instance with the `logs_path` as its `data_dir`.

```rust
Self {
    data_dir: logs_path,
}
```
- `Self` refers to the `FilesystemLogger` struct.
- Assign `logs_path` to the `data_dir` field, moving the `String` into the struct.
- The constructor returns the initialized `FilesystemLogger` instance.

</details>

**You should be good-to-go! Try implementing the `new` constructor in `src/filesystem_logger.rs`!** Click `Run` at the top of the Replit when you're done to see if the test `tests::filesystem_logger_tests::test_logger_creation ...` passes.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/run.png" alt="run" width="15%" height="auto">
</p>