# Fetching Blockchain Data

Regardless of how your Lightning node retrieves data from the Bitcoin blockchain (ex: Bitcoin Core, Esplora, Electrum, etc.), it's going to need to be notified when new transactions are mined. This way, it can ensure that our counterparty is not attempting to cheat us by publishing an old channel-state.

From an LDK perspective, there are different architectural approaches that are required, depending on if we are sourcing our blockchain data from a block-oriented interface (ex: Bitcoin Core) or a transaction-oriented interface (ex: Esplora, Electrum).

### Block-Oriented Interace
If we're conntecting our node to a block-centric interface, we will need to implement the `BlockSource` trait. This trait defines methods to fetch the following information from a given block source.
1) Block Height
2) Block Data (Header + Transactions)
3) Block Hash

Once we've implemented a `BlockSource`, we can pass that information to the below components, which LDK provides. These components will take care of processing new blocks and informing each relevant LDK component of any new transactions so that each component can act accordingly.
- `ChainPoller`: The `ChainPoller` takes a `BlockSource` as an input and contains functionality to validate new blocks.
- `SpvClient`: The `SpvClient` takes a `ChainPoller` as an input, along with the various LDK components that need to be notified of new blocks, and ensures proper orchestration across all components in LDK.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/spv.png" alt="spv" width="100%" height="auto">
</p>

### Transaction-Oriented Interace
(to-do!)

## Updating Our BitcoinClient
Since our Lightning node will connect the the bitcoin core node running in the background of our Repl, we'll be retrieving block-oriented data. Therefore, we'll need to implment the `BlockSouce` interface!

The `BlockSource` interface, with its required methods, can be seen below. As we learned earlier, these functions will be called privately within the `ChainPoller`, which is subsequently passed into our `SpvClient`.

```rust
pub trait BlockSource: Sync + Send {
    fn get_header<'a>(
        &'a self,
        header_hash: &'a BlockHash,
        height_hint: Option<u32>,
    ) -> AsyncBlockSourceResult<'a, BlockHeaderData>;

    fn get_block<'a>(
        &'a self,
        header_hash: &'a BlockHash,
    ) -> AsyncBlockSourceResult<'a, BlockData>;

    fn get_best_block<'a>(
        &'a self,
    ) -> AsyncBlockSourceResult<'_, (BlockHash, Option<u32>)>;
}
```

Since our Lightning node is retrieving blockchain data from Bitcoin Core, we'll complete these functions by fetching and returning the required data by querying Bitcoin Core's JSON RPC interface.

To keep things organized, we’ll encapsulate the `BlockSource` functionality inside our `BitcoinClient` struct. This way, all interactions with Bitcoin Core (fetching blocks, broadcasting transactions, etc.) live in one place.

In Rust, we define these behaviors using the `impl` keyword, which lets us attach methods to our `BitcoinClient`. 

```rust
impl BlockSource for BitcoinClient {
    fn get_header(header_hash: BlockHash, height_hint: Option<u32>) {
        // implement here
    }

    fn get_block(header_hash: BlockHash) {
        // implement here
    }

    fn get_best_block() {
        // implement here
    }
}
```

One this is completed, these functions will be available within the `BitcoinClient` structure. So, for example, you could obtain the best block's chain hash using:

```rust
let bitcoin_rpc_client = BitcoinClient::new(host, port, rpc_user, rpc_password, network).await.unwrap();
let best_block = bitcoin_rpc_client.get_best_block();
```


## ⚡️ Implement `BlockSource` For Our `BitcoinClient`
Complete the implementation of `BlockSource` for `BitcoinClient` in `src/ch2_setup/bitcoin_client.rs`. You'll need to implement:

1. `get_header`: Fetches a block header by its hash
2. `get_block`: Fetches a complete block by its hash
3. `get_best_block`: Fetches information about the most recent block

```rust
impl BlockSource for BitcoinClient {
    fn get_header<'a>(
        &'a self, header_hash: &'a BlockHash, height_hint: Option<u32>,
    ) -> AsyncBlockSourceResult<'a, BlockHeaderData> {
        Box::pin(async move { 
            let header_hash = serde_json::json!(header_hash.to_string());
            Ok(self.bitcoind_rpc_client.call_method("getblockheader", &[header_hash]).await?)
        })
    }

    fn get_block<'a>(
        &'a self, header_hash: &'a BlockHash,
    ) -> AsyncBlockSourceResult<'a, BlockData> {
        Box::pin(async move {
            // your code here
        })
    }

    fn get_best_block(&self) -> AsyncBlockSourceResult<(BlockHash, Option<u32>)> {
        Box::pin(async move { 
            // your code here
        })
    }
}
```

### Available Methods

Remember, `self.bitcoind_rpc_client` is an `RpcClient`, so it provides some RPC methods that we can utilize:
- `get_header(header_hash, height_hint)` - Returns block header data
- `get_block(header_hash)` - Returns full block data
- `get_best_block()` - Returns the latest block info

Note, the first method, `get_header` had been provided for you. You can use this to guide your completion of the rest of the methods. Also, you'll notice that the following code has been provided for you within each function:

```rust
Box::pin(async move { 
    // your code here
})
```
This is included because our function is asynchronous, and at compile time, we don’t know the size of the data it will eventually return. To handle this, we **“box”** the future to give it a fixed size and **“pin”** it in on the heap to ensure its memory location remains stable.

While understanding this concept is important for asynchronous programming in Rust, it’s not essential for completing this workshop. Therefore, this code has been provided for you.