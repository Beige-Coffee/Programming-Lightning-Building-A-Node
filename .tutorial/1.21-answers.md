# Answers

## 1) Implement `new` Constructor For FilesystemLogger
```
src/logger.rs
```

```rust
impl FilesystemLogger {
  pub(crate) fn new(data_dir: String) -> Self {
    let logs_path = format!("{}/logs", data_dir);
    fs::create_dir_all(logs_path.clone()).unwrap();

    Self {
      data_dir: logs_path, 
    }
  }
}
```

## 2) Implement LDK `Logger` Trait For FilesystemLogger
```
src/logger.rs
```

```rust
impl Logger for FilesystemLogger {
  fn log(&self, record: Record) {
    let raw_log = record.args.to_string();
    let log = format!(
        "{} {:<5} [{}:{}] {}\n",
        Utc::now().format("%Y-%m-%d %H:%M:%S%.3f"),
        record.level.to_string(),
        record.module_path,
        record.line,
        raw_log
      );
    let logs_file_path = format!("{}/logs.txt", self.data_dir.clone());
    fs::OpenOptions::new()
    .create(true)
    .append(true)
    .open(logs_file_path)
    .unwrap()
    .write_all(log.as_bytes())
    .unwrap();
  }
}
```

## 3) Implement the `new` constructor For Our `BitcoindClient`
```
src/bitcoind_client.rs
```

```rust
impl BitcoindClient {
  pub(crate) async fn new(
    host: String, port: u16, rpc_user: String, rpc_password: String, network: Network,
    handle: tokio::runtime::Handle, logger: Arc<FilesystemLogger>,
  ) -> std::io::Result<Self> {
    let http_endpoint = HttpEndpoint::for_host(host.clone()).with_port(port);

    let rpc_credentials = base64::encode(format!("{}:{}", rpc_user, rpc_password));

    let bitcoind_rpc_client = RpcClient::new(&rpc_credentials, http_endpoint).map_err(|e| {
        eprintln!("Failed to create RpcClient: {:?}", e);
        std::io::Error::new(std::io::ErrorKind::Other, format!("RpcClient creation failed: {:?}", e))
    })?;

    let mut fees: HashMap<ConfirmationTarget, AtomicU32> = HashMap::new();

    fees.insert(ConfirmationTarget::MaximumFeeEstimate, AtomicU32::new(50000));
    fees.insert(ConfirmationTarget::UrgentOnChainSweep, AtomicU32::new(5000));
    fees.insert(
        ConfirmationTarget::MinAllowedAnchorChannelRemoteFee,
        AtomicU32::new(MIN_FEERATE),
    );
    fees.insert(
        ConfirmationTarget::MinAllowedNonAnchorChannelRemoteFee,
        AtomicU32::new(MIN_FEERATE),
    );
    fees.insert(ConfirmationTarget::AnchorChannelFee, AtomicU32::new(MIN_FEERATE));
    fees.insert(ConfirmationTarget::NonAnchorChannelFee, AtomicU32::new(2000));
    fees.insert(ConfirmationTarget::ChannelCloseMinimum, AtomicU32::new(MIN_FEERATE));
    fees.insert(ConfirmationTarget::OutputSpendingFee, AtomicU32::new(MIN_FEERATE));


    let client = Self {
      bitcoind_rpc_client: Arc::new(bitcoind_rpc_client),
      host,
      port,
      rpc_user,
      rpc_password,
      network,
      fees: Arc::new(fees),
      handle: handle.clone(),
      logger,
    };

    BitcoindClient::poll_for_fee_estimates(
        client.fees.clone(),
        client.bitcoind_rpc_client.clone(),
        handle,
    );

    Ok(client)
  }

}
```

## 4) Implement `BlockSource` For Our `BitcoinClient`
```
src/bitcoind_client.rs
```

```rust
impl BlockSource for BitcoindClient {
  fn get_header<'a>(
    &'a self, header_hash: &'a BlockHash, height_hint: Option<u32>,
  ) -> AsyncBlockSourceResult<'a, BlockHeaderData> {
    Box::pin(async move { 
      let header_hash = serde_json::json!(header_hash.to_string());
      Ok(self.bitcoind_rpc_client.call_method("getblockheader", &[header_hash]).await?)
    })
  }

  fn get_block<'a>(
    &'a self, header_hash: &'a BlockHash,
  ) -> AsyncBlockSourceResult<'a, BlockData> {
    Box::pin( async move {
      let header_hash = serde_json::json!(header_hash.to_string());
      let verbosity = serde_json::json!(0);
      Ok(BlockData::FullBlock(self.bitcoind_rpc_client.call_method("getblock", &[header_hash, verbosity]).await?))
    })
  }

  fn get_best_block<'a>(&'a self) -> AsyncBlockSourceResult<(BlockHash, Option<u32>)> {
    Box::pin(async move {
      Ok(self.bitcoind_rpc_client.call_method("getblockchaininfo", &[]).await?)
    })
  }
}
```

## 5) Implement `BroadcasterInterface` On Our `BitcoinClient`
```
src/bitcoind_client.rs
```

```rust
impl BroadcasterInterface for BitcoindClient {
  fn broadcast_transactions(&self, txs: &[&Transaction]) {
    let txn = txs.iter().map(|tx| encode::serialize_hex(tx)).collect::<Vec<_>>();
    for tx in txn {
      let bitcoind_rpc_client = Arc::clone(&self.bitcoind_rpc_client);
      let logger = Arc::clone(&self.logger);
      self.handle.spawn(async move {
        let tx_json = serde_json::json!(tx);
        match bitcoind_rpc_client
          .call_method::<serde_json::Value>("sendrawtransaction", &[tx_json])
          .await

        {
          Ok(result) => {
            log_info!(logger, "Successfully broadcasted transaction: {:?}", result);
          },
          Err(e) => {
            log_error!(logger, "Failed to broadcast transaction: {:?}", e);
          }
        }
      });
    }
  }
}
```

## 6) Implement `FeeEstimator` On Our `BitcoinClient`
```
src/bitcoind_client.rs
```

```rust
impl FeeEstimator for BitcoindClient {
  fn get_est_sat_per_1000_weight(&self, confirmation_target: ConfirmationTarget) -> u32 {
    self.fees.get(&confirmation_target).unwrap().load(Ordering::Acquire)
  }
}
```

## 7) Implement `create_funding_transaction`
```
src/onchain_wallet.rs
```

```rust
pub fn create_funding_transaction(&self,
                output_script: ScriptBuf,
                amount: Amount,
                confirmation_target: ConfirmationTarget,
                locktime: LockTime) -> Transaction {
  // get lock on wallet
  let mut wallet = self.inner.lock().unwrap();

  // create tx builder
  let mut tx_builder = wallet.build_tx();

  // get fee rate, assuming normal fees
  let fee_rate =
    self.fee_estimator.get_est_sat_per_1000_weight(confirmation_target) as u64;
  let fees = FeeRate::from_sat_per_kwu(fee_rate);

  tx_builder.add_recipient(output_script, amount).fee_rate(fees).nlocktime(locktime);

  // build the transaction
  let mut psbt = tx_builder.finish().unwrap();

  let sign_options = SignOptions::default();

  wallet.sign(&mut psbt, sign_options).unwrap();

  let tx: Transaction = psbt.extract_tx().unwrap();

  tx
}
```

## 8) Implement `write` for our `FilesystemStore`
```
src/filesystem_store.rs
```

```rust
fn write(
  &self, primary_namespace: &str, secondary_namespace: &str, key: &str, buf: &[u8],
) -> lightning::io::Result<()> {
  check_namespace_key_validity(primary_namespace, secondary_namespace, Some(key), "write")?;

  let mut dest_file_path = self.get_dest_dir_path(primary_namespace, secondary_namespace)?;
  dest_file_path.push(key);

  let parent_directory = dest_file_path.parent().ok_or_else(|| {
    let msg =
      format!("Could not retrieve parent directory of {}.", dest_file_path.display());
    std::io::Error::new(std::io::ErrorKind::InvalidInput, msg)
  })?;
  fs::create_dir_all(&parent_directory)?;

  // Do a crazy dance with lots of fsync()s to be overly cautious here...
  // We never want to end up in a state where we've lost the old data, or end up using the
  // old data on power loss after we've returned.
  // The way to atomically write a file on Unix platforms is:
  // open(tmpname), write(tmpfile), fsync(tmpfile), close(tmpfile), rename(), fsync(dir)
  let mut tmp_file_path = dest_file_path.clone();
  let tmp_file_ext = format!("{}.tmp", self.tmp_file_counter.fetch_add(1, Ordering::AcqRel));
  tmp_file_path.set_extension(tmp_file_ext);

  {
    let mut tmp_file = fs::File::create(&tmp_file_path)?;
    tmp_file.write_all(&buf)?;
    tmp_file.sync_all()?;
  }

  let res = {
    let inner_lock_ref = {
      let mut outer_lock = self.locks.lock().unwrap();
      Arc::clone(&outer_lock.entry(dest_file_path.clone()).or_default())
    };
    let _guard = inner_lock_ref.write().unwrap();

    fs::rename(&tmp_file_path, &dest_file_path)?;
    let dir_file = fs::OpenOptions::new().read(true).open(&parent_directory)?;
    dir_file.sync_all()?;
    Ok(())
  };

  self.garbage_collect_locks();

  res
}
```

## 9)  Accept Incoming Connections
```
src/networking.rs
```

```rust
pub async fn start_network_listener(
    peer_manager: Arc<MockPeerManager>,
    listening_port: u16,
) {
    tokio::spawn(async move {
        let listener = tokio::net::TcpListener::bind(format!("[::]:{}", listening_port))
            .await
            .expect("Failed to bind to listen port - is something else already listening on it?");
        loop {
            let tcp_stream = listener.accept().await.unwrap().0;
            let peer_mgr = peer_manager.clone();
            tokio::spawn(async move {
                setup_inbound(
                    peer_mgr,
                    tcp_stream.into_std().unwrap(),
                )
                .await;
            });
        }
    });
}
```

## 10)  Implement `FundingGenerationReady` for `handle_ldk_events`
```
src/events.rs
```

```rust
pub async fn handle_ldk_events(
    channel_manager: &ChannelManager, 
    bitcoind_client: BitcoindClient,
    on_chain_wallet: &OnChainWallet,
    keys_manager: KeysManager, 
    peer_manager: PeerManager,
    file_store: FileStore,
    event: Event
) {
    match event {
        Event::FundingGenerationReady {
            temporary_channel_id,
            counterparty_node_id,
            channel_value_satoshis,
            output_script,
            ..
        } => {

            let confirmation_target = ConfirmationTarget::NonAnchorChannelFee;

            // We set nLockTime to the current height to discourage fee sniping.
            let cur_height = channel_manager.current_best_block().height;
            let locktime = LockTime::from_height(cur_height).unwrap();

            let channel_amount = Amount::from_sat(channel_value_satoshis);

            let final_tx = on_chain_wallet.create_funding_transaction(
                output_script,
                channel_amount,
                confirmation_target,
                locktime);

            // Give the funding transaction back to LDK for opening the channel.
            channel_manager.funding_transaction_generated(
                temporary_channel_id,
                counterparty_node_id,
                final_tx)
        },
        Event::FundingTxBroadcastSafe { .. } => {},
        Event::PaymentClaimable { .. } => {},
        Event::PendingHTLCsForwardable { .. } => {},
        Event::SpendableOutputs { .. } => {},
        Event::ChannelReady { .. } => {},
        Event::ChannelClosed { .. } => {},
        _ => {},
    }
}
```

## 11)  Complete `open_channel`
```
src/commands.rs
```

```rust
pub fn open_channel(
  peer_pubkey: PublicKey, channel_amt_sat: u64, announce_channel: bool, with_anchors: bool,
  channel_manager: &ChannelManager,
) -> Result<(), ()> {
  let config = UserConfig {
    channel_handshake_limits: ChannelHandshakeLimits::default(),
    channel_handshake_config: ChannelHandshakeConfig {
      announce_for_forwarding: announce_channel,
      their_channel_reserve_proportional_millionths: 1_000,
      negotiate_anchors_zero_fee_htlc_tx: with_anchors,
      ..Default::default()
    },
    ..Default::default()
  };

  match channel_manager.create_channel(peer_pubkey, channel_amt_sat, 0, 0, None, Some(config)) {
    Ok(_) => {
      println!("EVENT: initiated channel with peer {}. ", peer_pubkey);
      return Ok(());
    },
    Err(e) => {
      println!("ERROR: failed to open channel: {:?}", e);
      return Err(());
    },
  }
}
```

## 12)  Complete `send_ln_payment`
```
src/commands.rs
```

```rust
pub fn send_ln_payment(
  channel_manager: &ChannelManager, invoice: &Bolt11Invoice, required_amount_msat: Option<u64>,
  outbound_payments: &mut OutboundPaymentInfoStorage, fs_store: &mut FileStore,
) {
  let payment_id = PaymentId((*invoice.payment_hash()).to_byte_array());
  let payment_secret = Some(*invoice.payment_secret());

  let pay_params_opt = payment_parameters_from_invoice(invoice);
  let (payment_hash, recipient_onion, route_params) = pay_params_opt.unwrap();

  outbound_payments.payments.insert(
    payment_id,
    PaymentInfo {
      preimage: None,
      secret: payment_secret,
      status: HTLCStatus::Pending,
      amt_msat: MillisatAmount(invoice.amount_milli_satoshis()),
    },
  );

  fs_store.write("", "", OUTBOUND_PAYMENTS_FNAME, &outbound_payments.encode()).unwrap();

  match channel_manager.send_payment(
    payment_hash,
    recipient_onion,
    payment_id,
    route_params,
    Retry::Timeout(Duration::from_secs(10)),
  ) {
    Ok(_) => {
      let payee_pubkey = invoice.recover_payee_pub_key();
      let amt_msat = invoice.amount_milli_satoshis().unwrap();
      println!("EVENT: initiated sending {} msats to {}", amt_msat, payee_pubkey);
    },
    Err(e) => {
      println!("ERROR: failed to send payment: {:?}", e);
      outbound_payments.payments.get_mut(&payment_id).unwrap().status = HTLCStatus::Failed;
      fs_store.write("", "", OUTBOUND_PAYMENTS_FNAME, &outbound_payments.encode()).unwrap();
    },
  };
}
```