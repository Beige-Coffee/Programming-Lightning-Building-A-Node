# Lightning Node Wallet

Great, we've now implemented a few interfaces that will enable our node to interact with the Bitcoin blockchain, accomplishing tasks such as broadcasting transactions and processing incoming blocks as they are mined.

Another crucial interface we will need to implement is our wallet. Once implemented, it will enable our node to perform a large variety of on-chain and off-chain tasks.


<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/wallet.png" alt="wallet" width="100%" height="auto">
</p>

#### Question: What functionality will the wallet assist with for our node? Think of all the tasks a Lightning node has to perform that involve keys.

<details>
  <summary>
    Answer
</summary>

When it comes to building a Lightning node wallet, it's helpful to differentiate between on-chain and off-chain wallet use cases.

#### On-Chain
For obvious reasons, we often think of Lightning as a "Layer 2" protocol, leading us to forget how tighly knit it is with Bitcoin's "Layer 1" blockchain. The below diagram sheds some light on various scenarious where having an on-chain wallet handy will help make for a more robust Lightning node.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/on_chain_usage.png" alt="key_usage" width="100%" height="auto">
</p>

1) **Layer 1 Payments**: One major reason to have an integrated on-chain wallet is so that your Lightning node can support sending and recieving bitcoin on-chain (Layer 1).
2) **Funding Transaction**: If you plan on opening channels yourself, you'll need to fund the channel, meaning you'll need on-chain bitcoin handy!
3) **Fee Bumping**: There are various scenarious where you may need to bump the fees on a transaction to ensure it gets confirmed in the blockchain. For example, perhaps fees have spiked after you broadcasted a punishment transaction and you need to increase fees ASAP. Additionally, newer Lightning channel versions support anchor outputs and even zero-fee commitments, meaning that you'll need to have fresh UTXOs available so that you can add fees whenever you want to broadcast these commitment transactions.
4) **Splicing (Channel Resizing)**: Splicing allows for channel partners to negotiate a new on-chain funding output for their channel. There are two main benefits that this provides. First, channel parties can increase or decrease the funds in their channel. Second, this change only requires one on-chain transaction (confirming the new 2-of-2 output). Without splicing, the channel partners would have had to close their channel and reopen it, which is two on-chain transactions. Not to mention that they would need to restablish any other channels they had.


#### Off-Chain
While not an extensive coverage of all wallet functionaltiy, the below diagram does help contextualize a few situations where Lightning node will need to leverage keys. Let's review them, step by step.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/off_chain_usage.png" alt="key_usage" width="100%" height="auto">
</p>

1) **Gossip**: The Gossip Network is how nodes on the Lightning network communicate with eachother. For example, announcing their presence or informing the network that they have a new channel open and ready for use. When communicating this information, it's important that recipients of data can verify that the data came from the right person. Since every public node on the Lightning network advertises a public key to identify itself by, it can use the private key associated with this public key to sign messages, certifying that the message did, in fact, originate from them.
2) **Payments**: Before making a payment, you'd probably want to verify that it's going to the correct person, right? Of course! Within the Lightning network, payment invoices include signatures, produced by your Lightning node's off-chain wallet, to verify that the invoice originated from the right person.
3) **On-Chain Operations**: Recall our exercise from earlier where we reviewed force-closed two channels in the middle of routing a payment? All of those transactions needed to be broadcasted on-chain. Additionally, if those commitment transactions supported *anchor outputs*, we may have needed to bring additional UTXOs to add the necessary fees. This on-chain activity requires that our Lightning node have an integrated on-chain wallet. As we'll see, there are multiple ways we can go about that.
4) **Channel Management**: Channel Management includes the messages that are sent between nodes to communicate a change in state. For example, oppening a channel, adding a new HTLC, closing a channel, etc. When constructing new states, we're updating commitment transactions, which means we'll have to send a new signature to our peer for the commitment transaction. This signature, of course, is produced by our wallet.

</details>

## Implementing Our On-Chain Wallet

Now that we've reviewed why an on-chain wallet is important, let's go ahead and implement one for our Lightning node!

Since LDK is a modular API-driven Lightning implementation, developers have a lot of flexibility when deciding how they'd like to integrate an on-chain wallet. We're already connected to Bitcoin Core, so we could use the wallet implementation that's provided via Core. On the other hand, if we wanted more customizability, we could use the Bitcoin Development Kit (BDK). Let's take a moment to review the differences between these two approaches.

<p align="center" style="width: 50%; max-width: 300px;">
  <img src="./tutorial_images/wallet_comparison.png" alt="wallet_comparision" width="100%" height="auto">
</p>

### Bitcoin Core

Since we already have a connection to Bitcoin Core, it would be relatively simple to integrate Bitcoin Core's wallet functionality into our Lightning Node. All we would have to do is build a few new functions that interface with the following Bitcoin Core RPC commands: `createrawtransaction`, `fundrawtransaction`, and `signrawtransactionwithwallet`. This would be very similar to some of the previous exercises we completed in this workbook. If you'd like to see an example of this, check out [LDK Sample](https://github.com/lightningdevkit/ldk-sample), which this workshop is heavily based off.

Another reason that leveraging Bitcoin Core as an on-chain wallet is relatively simple is that Bitcoin Core will ensure that our wallet is always up-to-date, monitoring the blockchain to see if we have any new UTXOs that we can spend from. Additionally, it will handle data persitance for us. That said, running Bitcoin Core is pretty resource-intensive, plus we could get more advanced wallet functionality if we use other solutions, such as the Bitcoin Development Kit.

### Bitcoin Development Kit

The Bitcoin Development Kit (BDK) is very similar to the Lightning Development Kit, in that it provides lightweight, highly customizable wallets with robust support for descriptors and miniscirpt. However, with this flexibilty and functionality comes a little extra complexity. For instance, we'll need to configure a BDK wallet to periodically sync with a block source (full node, simple payment verification node, Esplora server, or Electrum server), and we'll need to configure the data persistance ourselves.

From a Lightning node perspective, once great benefit of using BDK as our wallet is that we can use a single seed for our entire application. We'll cover this in depth in the next section, but the idea is that our Lightning keys will simply be a hardened derivation path from the seed that we use to instantiate our on-chain wallet! Cool, eh?

## ⚡️ Implement On-Chain Functionality With BDK


For this exercise, we'll implement on-chain transaction functionality within our `BitcoinClient`. This way, our Lightning node will be able to generate and broadcast an on-chain transaction when needed.

As we're building these functions, imagine we're creating a 2-of-2 funding transaction, as that would be an example of a transaction that our Lightning node will need to create **using our on-chain wallet**. Reminder, we need to use our on-chain wallet because that wallet will be signing (unlocking) the on-chain UTXO that is funding this channel.

### ⚡️ Implement `create_raw_transaction`

For the exercises on this page, head back over to the `src/bitcoind_client.rs` file!

We'll start with creating a raw transaction. To do this, we'll use Bitcoin Core's `createrawtransaction` RPC command. As an input, this function will take a hashmap (dictionary) of `address`: `amount` outputs, describing where the funds are being sent. You can read more about the other arguments that this RPC command takes [here](https://developer.bitcoin.org/reference/rpc/createrawtransaction.html).

This function will return a `RawTx` type, which is a `String`. Note, this transaction is not yet ready to broadcast, as it doesn't have inputs or a signature yet!

```rust
pub async fn create_raw_transaction(&self, outputs: Vec<HashMap<String, f64>>) -> RawTx {
    // Step 1: Convert outputs to JSON

    // Step 2 & 3: Call createrawtransaction and return result
}
```
<details> <summary> Step 1: Convert Outputs to JSON </summary>

First, we'll need to serialize the `outputs` vector (containing hashmaps of address : amount pairs) into a JSON value for the RPC call.

```rust
let outputs_json = serde_json::json!(outputs);
```

- Use `serde_json::json!(outputs)` to convert `outputs` into a JSON array.

</details>

<details> <summary> Step 2: Call the RPC Method </summary>
    
Next, we'll invoke the `createrawtransaction` RPC method asynchronously, passing an empty inputs array (`[]`) and the serialized outputs. This will create a transaction with no inputs and the specified outputs. We'll add the inputs shortly!

```rust
self.bitcoind_rpc_client
    .call_method::<RawTx>(
        "createrawtransaction",
        &vec![serde_json::json!([]), outputs_json],
    )
```

- Use `self.bitcoind_rpc_client.call_method::<RawTx>` to call `"createrawtransaction"`.
- Pass `&vec![serde_json::json!([]), outputs_json]` as arguments: an empty array for inputs and the outputs JSON.

</details>

<details> <summary> Step 3: Handle the Response </summary>

After we call the async `createrawtransaction` command, we'll have to wait the RPC response and return the `RawTx` (a `String` containing the raw transaction hex).

```rust
self.bitcoind_rpc_client
    .call_method::<RawTx>(
        "createrawtransaction",
        &vec![serde_json::json!([]), outputs_json],
    )
    .await
    .unwrap()
```

- `.await` waits for the async RPC call to complete.
- `.unwrap()` assumes the call succeeds (in a production environment, handle errors properly).

</details>

### ⚡️ Implement `fund_raw_transaction`

As mentioned above, once we get our transaction hex back from `create_raw_transaction`, we will need to find inputs to use. To accomplish this, we can use the RPC command `fund_raw_transaction`. This command will take a transaction (in the form of a hex string) and return a signed transaction - also in the form of a hex string. You can read more about it [here](https://developer.bitcoin.org/reference/rpc/fundrawtransaction.html?highlight=fundrawtransaction).

Another important thing to note is that this RPC command will add, at most, one change output to the outputs.

```rust
pub async fn fund_raw_transaction(&self, raw_tx: RawTx) -> FundedTx {
    // Step 1: Convert raw transaction to JSON

    // Step 2: Set RPC options
    
        // Convert fee rate from satoshis per KW to satoshis per vB

        // Disable RBF to prevent accidental fund loss

    // Step 3: Call fundrawtransaction and return result

}
```

<details> <summary> Step 1: Convert Raw Transaction to JSON </summary>

As we've seen many times before, we'll need to start by serializing the `raw_tx` (a `RawTx` containing the transaction hex string) into a JSON value for the RPC call.

```rust
let raw_tx_json = serde_json::json!(raw_tx.0);
```

- Use `serde_json::json!(raw_tx.0)` to convert the hex string (accessed via `raw_tx.0`) into a JSON string.
- This matches the expected format for `fundrawtransaction`’s transaction parameter.

</details>

<details> <summary> Step 2: Set RPC Options </summary>
    
Next, we'll need to create a JSON object specifying the fee rate.

```rust
let options = serde_json::json!({
    "fee_rate": self
        .get_est_sat_per_1000_weight(ConfirmationTarget::NonAnchorChannelFee) as f64 / 250.0
});
```

- Calculate `fee_rate` by fetching the fee estimate for `ConfirmationTarget::NonAnchorChannelFee` (in satoshis per KW), converting to satoshis per vB: divide by 250 (since 1 vB = 4 WU, and 1000 WU = 1 KW).
- Use `serde_json::json!` to create the options object.

</details>

<details> <summary> Step 3: Call the RPC Method </summary>
    
Finally, invoke `fundrawtransaction` asynchronously, passing the transaction JSON and options, and return the `FundedTx`.

```rust
self.bitcoind_rpc_client
    .call_method("fundrawtransaction", &[raw_tx_json, options])
    .await
    .unwrap()
```

- Use `self.bitcoind_rpc_client.call_method()` to call `"fundrawtransaction"`.
- Pass `&[raw_tx_json, options]` as arguments.
- `.await` waits for the RPC response, and `.unwrap()` assumes success (handle errors properly in production).

</details>

### ⚡️ Implement `sign_raw_transaction_with_wallet`

Now that we have our transaction hex, complete with inputs and outputs, we're ready to add a signature. To do this, we'll need to call Bitcoin Core's RPC command `signrawtransactionwithwallet`. This command takes a transaction hex and returns a signed transaction, ready to be broadcasted!

```rust
pub async fn sign_raw_transaction_with_wallet(&self, tx_hex: String) -> SignedTx {
    // Step 1: Convert transaction hex to JSON

    // Step 2 & 3: Call signrawtransactionwithwallet and return result
}
```

<details> <summary> Step 1: Convert Transaction Hex to JSON </summary>

You know the drill! Let's begin by serializing the `tx_hex` string (the raw transaction hex) into a JSON value for the RPC call.

```rust
let tx_hex_json = serde_json::json!(tx_hex);
```

- Use `serde_json::json!(tx_hex)` to convert the hex string into a JSON string.

</details>

<details> <summary> Step 2: Call the RPC Method </summary>

Invoke the `signrawtransactionwithwallet` RPC method asynchronously, passing the transaction hex JSON.

```rust
self.bitcoind_rpc_client
    .call_method("signrawtransactionwithwallet", &vec![tx_hex_json])
```

- Use `self.bitcoind_rpc_client.call_method()` to call `"signrawtransactionwithwallet"`.
- Pass `&vec![tx_hex_json]` as the sole argument (the transaction hex).

</details>

<details> <summary> Step 3: Handle the Response </summary>

Call `signrawtransactionwithwallet`, await the RPC response, and return the `SignedTx` (a signed transaction hex string).

```rust
self.bitcoind_rpc_client
    .call_method("signrawtransactionwithwallet", &vec![tx_hex_json])
    .await
    .unwrap()
```

- `.await` waits for the async RPC call to complete.
- `.unwrap()` assumes the call succeeds (in production, handle errors properly).

</details>

### ⚡️ Implement `send_raw_transaction`

We're almost there! Now, we'll implement `send_raw_transaction` so that our application can broadcast on-chain transactions.

At this point, you may be wondering: "Why do we need to implement `sign_raw_transaction_with_wallet`? Didn't we already implement a `BroadcastInterface`?".

Those would be great questions. In reality, LDK will broadcast the funding transaction for us (more on that later!). All we have to do is hand LDK the signed transaction. However, if we want to add additional broadcast functionality, then we will have this helper function available.

```rust
pub async fn send_raw_transaction(&self, raw_tx: RawTx) {
    // Step 1: Convert transaction hex to JSON

    // Step 2 & 3: Call sendrawtransaction

}
```

<details> <summary> Step 1: Convert Transaction Hex to JSON </summary>
    
Again, let's serialize the `raw_tx` (a `RawTx` containing the transaction hex string) into a JSON value for the RPC call.

```rust
let raw_tx_json = serde_json::json!(raw_tx.0);
```

- Use `serde_json::json!(raw_tx.0)` to convert the hex string (accessed via `raw_tx.0`) into a JSON string.

</details>

<details> <summary> Step 2: Call the RPC Method </summary>
    
Next, invoke the `sendrawtransaction` RPC method asynchronously, passing the transaction hex JSON.

```rust
self.bitcoind_rpc_client
    .call_method::<Txid>("sendrawtransaction", &[raw_tx_json])
```

- Use `self.bitcoind_rpc_client.call_method()` to call `"sendrawtransaction"`.
- Pass `&[raw_tx_json]` as the sole argument (the transaction hex).

</details>

<details> <summary> Step 3: Handle the Response </summary>
    
Finally, just as we've done multiple times thus far, let's handle the result. In this case, `send_raw_transaction` does not return any value, so we will discard the result by adding a `;` to the end of the last statement.

```rust
self.bitcoind_rpc_client
    .call_method::<Txid>("sendrawtransaction", &[raw_tx_json])
    .await
    .unwrap();
```

- `.await` waits for the async RPC call to complete.
- `.unwrap()` assumes the call succeeds (in production, handle errors properly).
- The `Txid` (transaction ID) is received but not used, as the method’s purpose is to broadcast. Therefore, we place a `;` after `unwrap()`, ensuring we don't return a value.

</details>